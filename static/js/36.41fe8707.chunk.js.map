{"version":3,"sources":["../node_modules/@tsparticles/shape-text/browser/index.js","../node_modules/@tsparticles/shape-text/browser/TextDrawer.js"],"names":["async","loadTextShape","engine","refresh","arguments","length","undefined","TextDrawer","addShape","validTypes","draw","data","drawText","init","container","options","actualOptions","find","t","isInArray","particles","shape","type","shapeOptions","map","promises","executeOnSingleOrMultiple","push","loadFont","font","weight","Promise","all","particleInit","particle","includes","character","shapeData","textData","value","text","itemFromSingleOrMultiple","randomIndexData","resolve"],"mappings":"uHAAA,kEACOA,eAAeC,EAAcC,GAAwB,IAAhBC,IAAOC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAC/C,MAAM,WAAEG,SAAqB,+CACvBL,EAAOM,SAASC,aAAY,IAAIF,EAAcJ,EACxD,C,mCCJA,yGACO,MAAMM,EAAa,CAAC,OAAQ,YAAa,OAAQ,kBACjD,MAAMF,EACT,UAAMG,CAAKC,GACP,MAAM,SAAEC,SAAmB,+BAC3BA,EAASD,EACb,CACA,UAAME,CAAKC,GACP,MAAMC,EAAUD,EAAUE,cAC1B,GAAIP,EAAWQ,MAAMC,GAAMC,YAAUD,EAAGH,EAAQK,UAAUC,MAAMC,QAAQ,CACpE,MAAMC,EAAed,EAChBe,KAAKN,GAAMH,EAAQK,UAAUC,MAAMN,QAAQG,KAC3CD,MAAMC,KAAQA,IAAIO,EAAW,GAClCC,YAA0BH,GAAeF,IACrCI,EAASE,KAAKC,YAASP,EAAMQ,KAAMR,EAAMS,QAAQ,UAE/CC,QAAQC,IAAIP,EACtB,CACJ,CACA,kBAAMQ,CAAanB,EAAWoB,GAC1B,IAAKA,EAASb,QAAUZ,EAAW0B,SAASD,EAASb,OACjD,OAEJ,MAAMe,EAAYF,EAASG,UAC3B,QAAkB/B,IAAd8B,EACA,OAEJ,MAAME,EAAWF,EAAUG,WACVjC,IAAbgC,IAGJJ,EAASM,KAAOC,YAAyBH,EAAUJ,EAASQ,uBACtDX,QAAQY,UAClB,E","file":"static/js/36.41fe8707.chunk.js","sourcesContent":["import { validTypes } from \"./TextDrawer.js\";\nexport async function loadTextShape(engine, refresh = true) {\n    const { TextDrawer } = await import(\"./TextDrawer.js\");\n    await engine.addShape(validTypes, new TextDrawer(), refresh);\n}\n","import { executeOnSingleOrMultiple, isInArray, itemFromSingleOrMultiple, loadFont, } from \"@tsparticles/engine\";\nexport const validTypes = [\"text\", \"character\", \"char\", \"multiline-text\"];\nexport class TextDrawer {\n    async draw(data) {\n        const { drawText } = await import(\"./Utils.js\");\n        drawText(data);\n    }\n    async init(container) {\n        const options = container.actualOptions;\n        if (validTypes.find((t) => isInArray(t, options.particles.shape.type))) {\n            const shapeOptions = validTypes\n                .map((t) => options.particles.shape.options[t])\n                .find((t) => !!t), promises = [];\n            executeOnSingleOrMultiple(shapeOptions, (shape) => {\n                promises.push(loadFont(shape.font, shape.weight));\n            });\n            await Promise.all(promises);\n        }\n    }\n    async particleInit(container, particle) {\n        if (!particle.shape || !validTypes.includes(particle.shape)) {\n            return;\n        }\n        const character = particle.shapeData;\n        if (character === undefined) {\n            return;\n        }\n        const textData = character.value;\n        if (textData === undefined) {\n            return;\n        }\n        particle.text = itemFromSingleOrMultiple(textData, particle.randomIndexData);\n        await Promise.resolve();\n    }\n}\n"],"sourceRoot":""}